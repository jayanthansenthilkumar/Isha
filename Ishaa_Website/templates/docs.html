{% extends "base.html" %}

{% block title %}{{ title }} - Ishaa Framework{% endblock %}

{% block head %}
<style>
/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   DOCUMENTATION PAGE STYLES
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
.docs-layout {
    display: grid;
    grid-template-columns: 260px 1fr;
    gap: 0;
    min-height: 100vh;
    padding-top: 70px;
}

/* ‚îÄ‚îÄ Sidebar ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.docs-sidebar {
    position: sticky;
    top: 70px;
    height: calc(100vh - 70px);
    overflow-y: auto;
    background: var(--bg-alt);
    border-right: 1px solid var(--border);
    padding: 2rem 0;
    scrollbar-width: thin;
}
.docs-sidebar::-webkit-scrollbar { width: 4px; }
.docs-sidebar::-webkit-scrollbar-thumb { background: var(--surface-light); border-radius: 2px; }

.sidebar-section {
    margin-bottom: 1.5rem;
}
.sidebar-label {
    display: block;
    padding: 0.3rem 1.5rem;
    font-size: 0.7rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--text-faint);
    margin-bottom: 0.2rem;
}
.sidebar-link {
    display: block;
    padding: 0.38rem 1.5rem 0.38rem 1.8rem;
    font-size: 0.85rem;
    color: var(--text-muted);
    font-weight: 500;
    transition: var(--transition);
    border-left: 2px solid transparent;
}
.sidebar-link:hover {
    color: var(--primary-light);
    background: rgba(99,102,241,0.05);
}
.sidebar-link.active {
    color: var(--primary-light);
    border-left-color: var(--primary);
    background: rgba(99,102,241,0.06);
    font-weight: 600;
}

/* Sidebar mobile toggle */
.docs-sidebar-toggle {
    display: none;
    position: fixed;
    bottom: 1.5rem;
    right: 1.5rem;
    z-index: 999;
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background: var(--primary);
    color: #fff;
    border: none;
    cursor: pointer;
    box-shadow: 0 4px 20px var(--primary-glow);
    font-size: 1.4rem;
    align-items: center;
    justify-content: center;
}

/* ‚îÄ‚îÄ Content ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
.docs-content {
    padding: 3rem 3.5rem 6rem;
    max-width: 860px;
    min-width: 0;
}
.docs-content h1 {
    font-size: 2.2rem;
    font-weight: 800;
    margin-bottom: 0.5rem;
    letter-spacing: -0.02em;
}
.docs-content .docs-subtitle {
    font-size: 1.05rem;
    color: var(--text-muted);
    margin-bottom: 2.5rem;
    line-height: 1.7;
}
.docs-content h2 {
    font-size: 1.5rem;
    font-weight: 800;
    margin: 3rem 0 1rem;
    padding-top: 1.5rem;
    border-top: 1px solid var(--border);
    color: var(--text);
    scroll-margin-top: 90px;
}
.docs-content h2:first-of-type {
    border-top: none;
    margin-top: 0;
    padding-top: 0;
}
.docs-content h3 {
    font-size: 1.15rem;
    font-weight: 700;
    margin: 2rem 0 0.8rem;
    color: var(--text);
    scroll-margin-top: 90px;
}
.docs-content h4 {
    font-size: 0.95rem;
    font-weight: 700;
    margin: 1.4rem 0 0.6rem;
    color: var(--text);
}
.docs-content p {
    font-size: 0.92rem;
    color: var(--text-muted);
    line-height: 1.8;
    margin-bottom: 1rem;
}
.docs-content ul, .docs-content ol {
    margin: 0.5rem 0 1.2rem 1.2rem;
    color: var(--text-muted);
    font-size: 0.92rem;
    line-height: 1.8;
}
.docs-content li { margin-bottom: 0.3rem; }
.docs-content code {
    font-family: var(--font-mono);
    background: var(--surface);
    padding: 0.15rem 0.4rem;
    border-radius: 5px;
    font-size: 0.84rem;
    border: 1px solid var(--border);
    color: var(--accent);
}
.docs-content pre {
    background: #0b1120;
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: var(--radius);
    padding: 1.3rem 1.5rem;
    overflow-x: auto;
    margin: 0.8rem 0 1.5rem;
    font-size: 0.85rem;
    line-height: 1.7;
}
.docs-content pre code {
    background: none;
    border: none;
    padding: 0;
    color: #e2e8f0;
    font-size: 0.85rem;
}

/* ‚îÄ‚îÄ Syntax highlighting ‚îÄ‚îÄ */
.sh-keyword    { color: #c678dd; font-weight: 600; }
.sh-string     { color: #98c379; }
.sh-comment    { color: #5c6370; font-style: italic; }
.sh-number     { color: #d19a66; }
.sh-decorator  { color: #e5c07b; }
.sh-builtin    { color: #56b6c2; }
.sh-function   { color: #61afef; }
.sh-operator   { color: #c678dd; }

/* Docs tables */
.docs-content table {
    width: 100%;
    border-collapse: collapse;
    margin: 0.8rem 0 1.5rem;
    font-size: 0.88rem;
}
.docs-content th,
.docs-content td {
    padding: 0.6rem 0.8rem;
    border: 1px solid var(--border);
    text-align: left;
}
.docs-content th {
    background: var(--surface);
    font-weight: 700;
    font-size: 0.82rem;
    text-transform: uppercase;
    letter-spacing: 0.04em;
    color: var(--text);
}
.docs-content td {
    color: var(--text-muted);
}
.docs-content td code {
    font-size: 0.82rem;
}

/* Tip / Note boxes */
.docs-tip {
    padding: 1rem 1.2rem;
    border-radius: var(--radius);
    margin: 1rem 0 1.5rem;
    font-size: 0.88rem;
    line-height: 1.7;
}
.docs-tip-info {
    background: rgba(99,102,241,0.08);
    border-left: 3px solid var(--primary);
    color: var(--text);
}
.docs-tip-warn {
    background: rgba(251,191,36,0.08);
    border-left: 3px solid #f59e0b;
    color: var(--text);
}
.docs-tip strong {
    display: block;
    margin-bottom: 0.3rem;
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 0.06em;
}
.docs-tip-info strong { color: var(--primary-light); }
.docs-tip-warn strong { color: #f59e0b; }

/* Version badge */
.docs-version {
    display: inline-block;
    font-size: 0.72rem;
    padding: 0.2rem 0.6rem;
    border-radius: 20px;
    background: linear-gradient(135deg, var(--primary), var(--accent));
    color: #fff;
    font-weight: 700;
    vertical-align: middle;
    margin-left: 0.5rem;
}

/* Search input (top of sidebar) */
.sidebar-search {
    padding: 0 1rem 1rem;
    margin-bottom: 0.5rem;
    border-bottom: 1px solid var(--border);
}
.sidebar-search input {
    width: 100%;
    padding: 0.5rem 0.8rem;
    border-radius: 8px;
    border: 1px solid var(--border);
    background: var(--surface);
    color: var(--text);
    font-size: 0.82rem;
    font-family: var(--font-sans);
    outline: none;
    transition: var(--transition);
}
.sidebar-search input::placeholder { color: var(--text-faint); }
.sidebar-search input:focus { border-color: var(--primary); }

/* Responsive */
@media (max-width: 900px) {
    .docs-layout {
        grid-template-columns: 1fr;
    }
    .docs-sidebar {
        position: fixed;
        left: -280px;
        top: 70px;
        width: 260px;
        z-index: 998;
        transition: left 0.3s ease;
    }
    .docs-sidebar.open {
        left: 0;
    }
    .docs-sidebar-toggle {
        display: flex;
    }
    .docs-content {
        padding: 2rem 1.5rem 4rem;
    }
}
@media (max-width: 480px) {
    .docs-content { padding: 1.5rem 1rem 3rem; }
    .docs-content h1 { font-size: 1.7rem; }
    .docs-content h2 { font-size: 1.25rem; }
    .docs-content pre { font-size: 0.78rem; padding: 1rem; }
}
</style>
{% endblock %}

{% block content %}
<div class="docs-layout">
    <!-- Sidebar Navigation -->
    <aside class="docs-sidebar" id="docs-sidebar">
        <div class="sidebar-search">
            <input type="text" id="docs-search" placeholder="Search docs..." autocomplete="off">
        </div>

        <div class="sidebar-section">
            <span class="sidebar-label">Getting Started</span>
            <a class="sidebar-link active" href="#introduction">Introduction</a>
            <a class="sidebar-link" href="#installation">Installation</a>
            <a class="sidebar-link" href="#hello-world">Hello World</a>
            <a class="sidebar-link" href="#project-structure">Project Structure</a>
        </div>
        <div class="sidebar-section">
            <span class="sidebar-label">Core</span>
            <a class="sidebar-link" href="#application">Application</a>
            <a class="sidebar-link" href="#routing">Routing</a>
            <a class="sidebar-link" href="#request">Request</a>
            <a class="sidebar-link" href="#response">Response</a>
        </div>
        <div class="sidebar-section">
            <span class="sidebar-label">Features</span>
            <a class="sidebar-link" href="#middleware">Middleware</a>
            <a class="sidebar-link" href="#blueprints">Blueprints</a>
            <a class="sidebar-link" href="#orm">ORM &amp; Database</a>
            <a class="sidebar-link" href="#authentication">Authentication</a>
            <a class="sidebar-link" href="#templates">Template Engine</a>
            <a class="sidebar-link" href="#websocket">WebSocket</a>
            <a class="sidebar-link" href="#background-tasks">Background Tasks</a>
            <a class="sidebar-link" href="#graphql">GraphQL</a>
        </div>
        <div class="sidebar-section">
            <span class="sidebar-label">Advanced</span>
            <a class="sidebar-link" href="#dependency-injection">Dependency Injection</a>
            <a class="sidebar-link" href="#plugins">Plugins</a>
            <a class="sidebar-link" href="#openapi">OpenAPI / Swagger</a>
            <a class="sidebar-link" href="#testing">Testing</a>
            <a class="sidebar-link" href="#cli">CLI Tool</a>
        </div>
        <div class="sidebar-section">
            <span class="sidebar-label">SARE Engine</span>
            <a class="sidebar-link" href="#sare-overview">Overview</a>
            <a class="sidebar-link" href="#sare-quickstart">Quick Start</a>
            <a class="sidebar-link" href="#sare-traffic">Traffic Analyzer</a>
            <a class="sidebar-link" href="#sare-optimizer">Adaptive Optimizer</a>
            <a class="sidebar-link" href="#sare-predictor">Latency Predictor</a>
            <a class="sidebar-link" href="#sare-codepath">Code Path Optimizer</a>
            <a class="sidebar-link" href="#sare-reports">Intelligence Reports</a>
            <a class="sidebar-link" href="#sare-config">Configuration</a>
        </div>
        <div class="sidebar-section">
            <span class="sidebar-label">RMF Engine</span>
            <a class="sidebar-link" href="#rmf-overview">Overview</a>
            <a class="sidebar-link" href="#rmf-quickstart">Quick Start</a>
            <a class="sidebar-link" href="#rmf-selector">Reality Selector</a>
            <a class="sidebar-link" href="#rmf-time-bound">Time-Bound Realities</a>
            <a class="sidebar-link" href="#rmf-parallel">Parallel Simulation</a>
            <a class="sidebar-link" href="#rmf-self-retiring">Self-Retiring</a>
            <a class="sidebar-link" href="#rmf-config">Configuration</a>
        </div>
        <div class="sidebar-section">
            <span class="sidebar-label">SEQP Engine</span>
            <a class="sidebar-link" href="#seqp-overview">Overview</a>
            <a class="sidebar-link" href="#seqp-quickstart">Quick Start</a>
            <a class="sidebar-link" href="#seqp-risk">Risk Analyzer</a>
            <a class="sidebar-link" href="#seqp-testgen">Auto Test Generator</a>
            <a class="sidebar-link" href="#seqp-pipeline">Pipeline Rewriter</a>
            <a class="sidebar-link" href="#seqp-guard">Deployment Guard</a>
            <a class="sidebar-link" href="#seqp-drift">Drift Intelligence</a>
            <a class="sidebar-link" href="#seqp-config">Configuration</a>
        </div>
        <div class="sidebar-section">
            <span class="sidebar-label">Reference</span>
            <a class="sidebar-link" href="#api-reference">API Reference</a>
            <a class="sidebar-link" href="#configuration">Configuration</a>
            <a class="sidebar-link" href="#architecture">Architecture</a>
        </div>
    </aside>

    <!-- Main Content -->
    <main class="docs-content">

        <!-- ‚îÄ‚îÄ‚îÄ INTRODUCTION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h1>Ishaa Framework Documentation <span class="docs-version">v1.2.0</span></h1>
        <p class="docs-subtitle">
            Complete guide to building modern, async-first web applications with Ishaa - the batteries-included Python framework with zero required dependencies, a self-evolving routing engine, multi-reality execution, and intelligent quality pipeline.
        </p>

        <h2 id="introduction">Introduction</h2>
        <p>Ishaa is a lightweight, modular, high-performance Python web framework built from scratch with <strong>zero required external dependencies</strong>. It features a complete ASGI-compatible architecture, a custom ORM, built-in authentication, a template engine, WebSocket support, GraphQL, dependency injection, and much more - all in pure Python.</p>

        <p>Ishaa brings together:</p>
        <ul>
            <li><strong>Simplicity of Flask</strong> - intuitive routing decorators and a minimal learning curve</li>
            <li><strong>Structure of Django</strong> - built-in ORM, templates, admin, and middleware pipeline</li>
            <li><strong>Performance of FastAPI</strong> - async-first ASGI architecture with dependency injection</li>
            <li><strong>Self-Evolution (SARE)</strong> - the world's first web framework that optimizes itself at runtime</li>
            <li><strong>Multi-Reality Execution (RMF)</strong> - one route, multiple behavioral universes with auto-promotion</li>
            <li><strong>Intelligent Quality (SEQP)</strong> - auto risk analysis, test generation, CI/CD rewriting, and deployment gates</li>
        </ul>

        <div class="docs-tip docs-tip-info">
            <strong>Tip</strong>
            Ishaa requires Python 3.8+ and has no mandatory third-party dependencies. All features work out of the box with the standard library.
        </div>


        <!-- ‚îÄ‚îÄ‚îÄ INSTALLATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h2 id="installation">Installation</h2>

        <h3>From Source (Recommended during development)</h3>
        <pre><code>git clone https://github.com/jayanthansenthilkumar/ISHAA_Framework.git
cd ISHAA_Framework
pip install -e .</code></pre>

        <h3>With Optional Dependencies</h3>
        <pre><code># Full installation with uvicorn, bcrypt, and jinja2
pip install -e ".[full]"</code></pre>

        <table>
            <thead><tr><th>Package</th><th>Purpose</th><th>Required</th></tr></thead>
            <tbody>
                <tr><td><code>uvicorn</code></td><td>Production ASGI server with auto-reload</td><td>Optional</td></tr>
                <tr><td><code>bcrypt</code></td><td>Alternative password hashing (faster)</td><td>Optional</td></tr>
                <tr><td><code>jinja2</code></td><td>Alternative template engine</td><td>Optional</td></tr>
                <tr><td><code>pytest</code></td><td>Test runner</td><td>Optional</td></tr>
            </tbody>
        </table>


        <!-- ‚îÄ‚îÄ‚îÄ HELLO WORLD ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h2 id="hello-world">Hello World</h2>
        <p>Create a file called <code>app.py</code>:</p>
        <pre><code>from ishaa import Ishaa

app = Ishaa("myapp")

@app.route("/")
async def hello(request):
    return {"message": "Hello from Ishaa! üåü"}

@app.route("/hello/&lt;name&gt;")
async def greet(request, name):
    return f"&lt;h1&gt;Hello, {name}!&lt;/h1&gt;"

app.run()</code></pre>
        <p>Run it:</p>
        <pre><code>$ python app.py
‚ú¶ Ishaa server running on http://127.0.0.1:8000</code></pre>


        <!-- ‚îÄ‚îÄ‚îÄ PROJECT STRUCTURE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h2 id="project-structure">Project Structure</h2>
        <p>When you scaffold a project with <code>ishaa create project myapp</code>, you get:</p>
        <pre><code>myapp/
‚îú‚îÄ‚îÄ app.py              # Main application entry
‚îú‚îÄ‚îÄ config.py           # Configuration settings
‚îú‚îÄ‚îÄ models.py           # Database models
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îî‚îÄ‚îÄ __init__.py     # Route blueprints
‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îî‚îÄ‚îÄ base.html       # Base template
‚îú‚îÄ‚îÄ static/
‚îÇ   ‚îú‚îÄ‚îÄ css/
‚îÇ   ‚îî‚îÄ‚îÄ js/
‚îî‚îÄ‚îÄ tests/
    ‚îî‚îÄ‚îÄ test_app.py     # Test suite</code></pre>


        <!-- ‚îÄ‚îÄ‚îÄ APPLICATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h2 id="application">Application</h2>
        <p>The <code>Ishaa</code> class is the core entry point. It manages routing, middleware, plugins, templates, lifecycle events, and the ASGI interface.</p>

        <h3>Creating an App</h3>
        <pre><code>from ishaa import Ishaa

app = Ishaa("myapp", debug=True)</code></pre>

        <h3>Default Configuration</h3>
        <table>
            <thead><tr><th>Key</th><th>Default</th><th>Description</th></tr></thead>
            <tbody>
                <tr><td><code>DEBUG</code></td><td><code>False</code></td><td>Enable debug mode</td></tr>
                <tr><td><code>SECRET_KEY</code></td><td><code>""</code></td><td>Secret for JWT / CSRF</td></tr>
                <tr><td><code>HOST</code></td><td><code>"127.0.0.1"</code></td><td>Server bind host</td></tr>
                <tr><td><code>PORT</code></td><td><code>8000</code></td><td>Server bind port</td></tr>
                <tr><td><code>STATIC_DIR</code></td><td><code>"static"</code></td><td>Static files directory</td></tr>
                <tr><td><code>TEMPLATE_DIR</code></td><td><code>"templates"</code></td><td>Template directory</td></tr>
            </tbody>
        </table>

        <h3>Running the App</h3>
        <pre><code>app.run(host="0.0.0.0", port=8080, debug=True, workers=4)</code></pre>

        <h3>Lifecycle Hooks</h3>
        <pre><code>@app.on_startup
async def startup():
    print("App started!")

@app.on_shutdown
async def shutdown():
    print("App shutting down...")</code></pre>


        <!-- ‚îÄ‚îÄ‚îÄ ROUTING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h2 id="routing">Routing</h2>
        <p>Ishaa supports typed URL parameters, multiple HTTP methods, named routes, and method shortcuts.</p>

        <h3>Basic Routes</h3>
        <pre><code>@app.route("/")
async def index(request):
    return "Welcome!"

@app.route("/items", methods=["GET", "POST"])
async def items(request):
    if request.method == "POST":
        data = await request.json()
        return {"created": data}, 201
    return {"items": []}</code></pre>

        <h3>Method Shortcuts</h3>
        <pre><code>@app.get("/health")
async def health(request):
    return {"status": "ok"}

@app.post("/upload")
async def upload(request):
    body = await request.body()
    return {"size": len(body)}</code></pre>

        <h3>Typed URL Parameters</h3>
        <table>
            <thead><tr><th>Type</th><th>Pattern</th><th>Example</th></tr></thead>
            <tbody>
                <tr><td><code>str</code></td><td><code>[^/]+</code></td><td><code>/users/&lt;name&gt;</code></td></tr>
                <tr><td><code>int</code></td><td><code>\d+</code></td><td><code>/users/&lt;int:id&gt;</code></td></tr>
                <tr><td><code>float</code></td><td><code>[\d.]+</code></td><td><code>/price/&lt;float:amount&gt;</code></td></tr>
                <tr><td><code>uuid</code></td><td><code>[0-9a-f]{8}-...</code></td><td><code>/item/&lt;uuid:uid&gt;</code></td></tr>
                <tr><td><code>slug</code></td><td><code>[a-z0-9]+(?:-[a-z0-9]+)*</code></td><td><code>/blog/&lt;slug:title&gt;</code></td></tr>
                <tr><td><code>path</code></td><td><code>.+</code></td><td><code>/files/&lt;path:filepath&gt;</code></td></tr>
            </tbody>
        </table>
        <pre><code>@app.route("/users/&lt;int:id&gt;")
async def get_user(request, id):
    return {"user_id": id}  # id is already an int</code></pre>

        <h3>Named Routes &amp; url_for</h3>
        <pre><code>@app.route("/profile/&lt;username&gt;", name="user_profile")
async def profile(request, username):
    return f"Profile: {username}"

url = app.url_for("user_profile", username="alice")
# => "/profile/alice"</code></pre>


        <!-- ‚îÄ‚îÄ‚îÄ REQUEST ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h2 id="request">Request</h2>
        <p>The <code>Request</code> object provides access to all incoming HTTP data.</p>

        <h3>Properties</h3>
        <table>
            <thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead>
            <tbody>
                <tr><td><code>method</code></td><td><code>str</code></td><td>HTTP method (GET, POST, etc.)</td></tr>
                <tr><td><code>path</code></td><td><code>str</code></td><td>URL path</td></tr>
                <tr><td><code>query_params</code></td><td><code>dict</code></td><td>Query string parameters</td></tr>
                <tr><td><code>headers</code></td><td><code>dict</code></td><td>HTTP headers (lowercased keys)</td></tr>
                <tr><td><code>cookies</code></td><td><code>dict</code></td><td>Parsed cookies</td></tr>
                <tr><td><code>content_type</code></td><td><code>str</code></td><td>Request content type</td></tr>
                <tr><td><code>client</code></td><td><code>tuple</code></td><td>Client (host, port)</td></tr>
                <tr><td><code>is_json</code></td><td><code>bool</code></td><td>True if JSON content type</td></tr>
                <tr><td><code>host</code></td><td><code>str</code></td><td>Request host header</td></tr>
                <tr><td><code>url</code></td><td><code>str</code></td><td>Full URL with query string</td></tr>
            </tbody>
        </table>

        <h3>Body Parsing</h3>
        <pre><code>@app.route("/example", methods=["POST"])
async def example(request):
    body = await request.body()      # raw bytes
    text = await request.text()      # decoded string
    data = await request.json()      # parsed JSON dict
    form = await request.form()      # form data dict</code></pre>


        <!-- ‚îÄ‚îÄ‚îÄ RESPONSE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h2 id="response">Response</h2>
        <p>Ishaa auto-detects response types from return values, or you can use explicit response classes.</p>

        <h3>Auto-Detection</h3>
        <pre><code>return "Hello"              # ‚Üí HTMLResponse
return {"key": "value"}     # ‚Üí JSONResponse
return [1, 2, 3]            # ‚Üí JSONResponse
return {"data": "ok"}, 201  # ‚Üí JSONResponse with status 201</code></pre>

        <h3>Explicit Responses</h3>
        <pre><code>from ishaa import Response, JSONResponse, HTMLResponse, RedirectResponse
from ishaa.response import StreamingResponse

return Response("Plain text", status_code=200, content_type="text/plain")
return JSONResponse({"ok": True}, status_code=201)
return HTMLResponse("&lt;h1&gt;Page&lt;/h1&gt;")
return RedirectResponse("/login")</code></pre>

        <h3>Cookies</h3>
        <pre><code>resp = JSONResponse({"logged_in": True})
resp.set_cookie("token", "abc123",
    max_age=3600, httponly=True, secure=True, samesite="Lax")
resp.delete_cookie("old_cookie")
return resp</code></pre>

        <h3>Streaming</h3>
        <pre><code>from ishaa.response import StreamingResponse

async def generate():
    for i in range(10):
        yield f"data: {i}\n\n"

return StreamingResponse(generate(), content_type="text/event-stream")</code></pre>


        <!-- ‚îÄ‚îÄ‚îÄ MIDDLEWARE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h2 id="middleware">Middleware</h2>
        <p>Ishaa provides a flexible middleware pipeline with built-in security middleware and support for custom classes.</p>

        <h3>Built-in Middleware</h3>
        <pre><code>from ishaa.middleware import (
    CORSMiddleware,
    RateLimitMiddleware,
    CSRFMiddleware,
    SecurityHeadersMiddleware,
)

# CORS - Cross-Origin Resource Sharing
app.add_middleware(CORSMiddleware(
    allow_origins=["https://example.com"],
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_credentials=True,
    max_age=600,
))

# Rate Limiting - per-IP, in-memory
app.add_middleware(RateLimitMiddleware(
    max_requests=100, window_seconds=60
))

# CSRF Protection
csrf = CSRFMiddleware(secret="your-secret")
app.add_middleware(csrf)

# Security Headers (X-Frame-Options, CSP, etc.)
app.add_middleware(SecurityHeadersMiddleware())</code></pre>

        <h3>Decorator-Based Hooks</h3>
        <pre><code>@app.before_request
async def log_request(request):
    print(f"{request.method} {request.path}")
    return None  # return a Response to short-circuit

@app.after_request
async def add_header(request, response):
    response.headers["X-Powered-By"] = "Ishaa"
    return response</code></pre>

        <h3>Custom Middleware Class</h3>
        <pre><code>from ishaa.middleware import Middleware

class TimingMiddleware(Middleware):
    async def before_request(self, request):
        import time
        request._start = time.time()
        return None

    async def after_request(self, request, response):
        import time
        elapsed = time.time() - request._start
        response.headers["X-Response-Time"] = f"{elapsed:.4f}s"
        return response

app.add_middleware(TimingMiddleware())</code></pre>


        <!-- ‚îÄ‚îÄ‚îÄ BLUEPRINTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h2 id="blueprints">Blueprints</h2>
        <p>Organize your application into modular sections with prefix routing.</p>
        <pre><code>from ishaa import Blueprint

api = Blueprint("api", prefix="/api/v1")

@api.route("/users")
async def list_users(request):
    return {"users": []}

@api.route("/users/&lt;int:id&gt;")
async def get_user(request, id):
    return {"user": id}

@api.before_request
async def api_auth(request):
    if "authorization" not in request.headers:
        return {"error": "Unauthorized"}, 401
    return None

# Register with app
app.register_blueprint(api)
# Routes: /api/v1/users, /api/v1/users/&lt;int:id&gt;</code></pre>


        <!-- ‚îÄ‚îÄ‚îÄ ORM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h2 id="orm">ORM &amp; Database</h2>
        <p>A lightweight ORM with SQLite support, model definitions, chainable query builder, and migrations.</p>

        <h3>Define Models</h3>
        <pre><code>from ishaa.orm import (
    Database, Model,
    IntegerField, TextField, FloatField,
    BooleanField, DateTimeField, JSONField, ForeignKeyField,
)

db = Database("app.db")

class User(Model):
    _table = "users"
    _db = db

    name = TextField()
    email = TextField(unique=True)
    age = IntegerField(default=0)
    is_active = BooleanField(default=True)
    created_at = DateTimeField(auto_now_add=True)</code></pre>

        <h3>Field Types</h3>
        <table>
            <thead><tr><th>Field</th><th>SQL Type</th><th>Extra Options</th></tr></thead>
            <tbody>
                <tr><td><code>IntegerField</code></td><td>INTEGER</td><td><code>primary_key</code>, <code>unique</code>, <code>index</code></td></tr>
                <tr><td><code>TextField</code></td><td>TEXT / VARCHAR(n)</td><td><code>max_length</code></td></tr>
                <tr><td><code>FloatField</code></td><td>REAL</td><td>-</td></tr>
                <tr><td><code>BooleanField</code></td><td>INTEGER</td><td>Auto bool‚Üîint conversion</td></tr>
                <tr><td><code>DateTimeField</code></td><td>TEXT (ISO)</td><td><code>auto_now</code>, <code>auto_now_add</code></td></tr>
                <tr><td><code>JSONField</code></td><td>TEXT</td><td>Auto JSON serialization</td></tr>
                <tr><td><code>ForeignKeyField</code></td><td>INTEGER</td><td><code>references</code>, <code>on_delete</code></td></tr>
            </tbody>
        </table>

        <h3>CRUD Operations</h3>
        <pre><code># Create table
User.create_table()

# Create record
user = User.create(name="Alice", email="alice@example.com", age=30)
print(user.id)  # Auto-generated ID

# Read
user = User.get(1)          # By primary key
all_users = User.all()      # All records

# Update
user.age = 31
user.save()

# Delete
user.delete_record()</code></pre>

        <h3>Query Builder</h3>
        <pre><code># Chainable queries
active_users = (User.query()
    .filter(is_active=True)
    .filter(age__gt=18)
    .order_by("name")
    .limit(10)
    .all())

# Count &amp; exists
count = User.query().filter(is_active=True).count()
exists = User.query().filter(email="alice@example.com").exists()

# Bulk operations
User.query().filter(is_active=False).delete()
User.query().filter(age__lt=18).update(is_active=False)

# Query operators: __gt, __lt, __gte, __lte, __ne,
#                  __like, __ilike, __in, __notin, __is</code></pre>

        <h3>Migrations</h3>
        <pre><code>from ishaa.orm import MigrationManager

mgr = MigrationManager(db)
mgr.init()

# Create migration
mgr.create_migration(
    "add_users_table",
    sql_up="CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)",
    sql_down="DROP TABLE users"
)

# Run pending migrations
mgr.run_migrations()</code></pre>


        <!-- ‚îÄ‚îÄ‚îÄ AUTHENTICATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h2 id="authentication">Authentication</h2>
        <p>Built-in password hashing, JWT tokens, session management, and route protection decorators.</p>

        <h3>Password Hashing</h3>
        <pre><code>from ishaa.auth import PasswordHasher

hasher = PasswordHasher()
hashed = hasher.hash("my_password")          # PBKDF2-HMAC-SHA256
is_valid = hasher.verify("my_password", hashed)  # True</code></pre>

        <h3>JWT Tokens</h3>
        <pre><code>from ishaa.auth import JWT

jwt = JWT(secret="your-secret-key", expiry_seconds=3600)
token = jwt.encode({"user_id": 1, "role": "admin"})
payload = jwt.decode(token)
# {"user_id": 1, "role": "admin", "exp": ..., "iat": ...}</code></pre>

        <h3>Session Management</h3>
        <pre><code>from ishaa.auth import SessionManager

sessions = SessionManager(max_age=3600)
session_id = sessions.create_session()
sessions.set(session_id, "user_id", 1)
value = sessions.get(session_id, "user_id")  # 1
sessions.destroy_session(session_id)</code></pre>

        <h3>Route Protection</h3>
        <pre><code>from ishaa.auth import AuthMiddleware, login_required, role_required

# Middleware approach
app.add_middleware(AuthMiddleware(
    jwt=jwt, exclude=["/login", "/register"]
))

# Decorator approach
@app.route("/dashboard")
@login_required
async def dashboard(request):
    return f"Welcome, user {request.state['user']['user_id']}!"

@app.route("/admin")
@role_required("admin")
async def admin_panel(request):
    return "Admin area"</code></pre>


        <!-- ‚îÄ‚îÄ‚îÄ TEMPLATES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h2 id="templates">Template Engine</h2>
        <p>Jinja-like template syntax with inheritance, includes, loops, conditionals, and filters - all built in.</p>

        <h3>Rendering Templates</h3>
        <pre><code>app = Ishaa("myapp")  # templates/ dir by default

@app.route("/page")
async def page(request):
    return app.render("page.html", title="Home", items=["a", "b"])</code></pre>

        <h3>Template Syntax</h3>
        <pre><code>&#123;# templates/base.html #&#125;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;&lt;title&gt;&#123;% block title %&#125;Default&#123;% endblock %&#125;&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
  &#123;% block content %&#125;&#123;% endblock %&#125;
&lt;/body&gt;
&lt;/html&gt;</code></pre>

        <pre><code>&#123;# templates/page.html #&#125;
&#123;% extends "base.html" %&#125;
&#123;% block title %&#125;&#123;&#123; title &#125;&#125;&#123;% endblock %&#125;
&#123;% block content %&#125;
  &lt;h1&gt;&#123;&#123; title|upper &#125;&#125;&lt;/h1&gt;

  &#123;% for item in items %&#125;
    &lt;p&gt;&#123;&#123; loop.index &#125;&#125;. &#123;&#123; item &#125;&#125;&lt;/p&gt;
  &#123;% endfor %&#125;

  &#123;% if user %&#125;
    &lt;p&gt;Welcome, &#123;&#123; user.name &#125;&#125;!&lt;/p&gt;
  &#123;% else %&#125;
    &lt;p&gt;Please log in.&lt;/p&gt;
  &#123;% endif %&#125;

  &#123;% include "_footer.html" %&#125;
&#123;% endblock %&#125;</code></pre>

        <h3>Built-in Filters</h3>
        <table>
            <thead><tr><th>Filter</th><th>Description</th><th>Example</th></tr></thead>
            <tbody>
                <tr><td><code>upper</code></td><td>Uppercase</td><td><code>&#123;&#123; name|upper &#125;&#125;</code></td></tr>
                <tr><td><code>lower</code></td><td>Lowercase</td><td><code>&#123;&#123; name|lower &#125;&#125;</code></td></tr>
                <tr><td><code>title</code></td><td>Title Case</td><td><code>&#123;&#123; name|title &#125;&#125;</code></td></tr>
                <tr><td><code>length</code></td><td>Length of value</td><td><code>&#123;&#123; items|length &#125;&#125;</code></td></tr>
                <tr><td><code>default</code></td><td>Fallback value</td><td><code>&#123;&#123; x|default("N/A") &#125;&#125;</code></td></tr>
                <tr><td><code>truncate</code></td><td>Truncate string</td><td><code>&#123;&#123; text|truncate(100) &#125;&#125;</code></td></tr>
                <tr><td><code>join</code></td><td>Join list</td><td><code>&#123;&#123; items|join(", ") &#125;&#125;</code></td></tr>
                <tr><td><code>escape</code></td><td>HTML escape</td><td><code>&#123;&#123; html|escape &#125;&#125;</code></td></tr>
                <tr><td><code>format_number</code></td><td>Number formatting</td><td><code>&#123;&#123; num|format_number &#125;&#125;</code></td></tr>
            </tbody>
        </table>


        <!-- ‚îÄ‚îÄ‚îÄ WEBSOCKET ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h2 id="websocket">WebSocket</h2>
        <p>Full-duplex WebSocket communication with rooms and broadcasting.</p>
        <pre><code>from ishaa.websocket import websocket_route, WebSocketRoom

chat_room = WebSocketRoom("chat")

@app.route("/ws")
@websocket_route
async def ws_handler(ws):
    await ws.accept()
    chat_room.add(ws)

    try:
        while True:
            data = await ws.receive_json()
            await chat_room.broadcast_json({
                "user": data["user"],
                "message": data["message"],
            })
    except Exception:
        chat_room.remove(ws)
        await ws.close()</code></pre>

        <h3>WebSocket Methods</h3>
        <table>
            <thead><tr><th>Method</th><th>Description</th></tr></thead>
            <tbody>
                <tr><td><code>accept()</code></td><td>Accept the connection</td></tr>
                <tr><td><code>close(code, reason)</code></td><td>Close the connection</td></tr>
                <tr><td><code>receive_text()</code></td><td>Receive text message</td></tr>
                <tr><td><code>receive_json()</code></td><td>Receive and parse JSON</td></tr>
                <tr><td><code>send_text(data)</code></td><td>Send text message</td></tr>
                <tr><td><code>send_json(data)</code></td><td>Send JSON message</td></tr>
                <tr><td><code>send_bytes(data)</code></td><td>Send binary data</td></tr>
            </tbody>
        </table>


        <!-- ‚îÄ‚îÄ‚îÄ BACKGROUND TASKS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h2 id="background-tasks">Background Tasks</h2>
        <p>Run tasks asynchronously with status tracking and periodic scheduling.</p>
        <pre><code>from ishaa.tasks import TaskQueue, task

queue = TaskQueue(max_workers=4)

@task(queue)
async def send_email(to, subject, body):
    import asyncio
    await asyncio.sleep(2)
    return f"Email sent to {to}"

# Dispatch
result = await send_email.delay("user@example.com", "Hello", "Welcome!")
print(result.task_id)   # UUID
print(result.status)    # PENDING ‚Üí RUNNING ‚Üí COMPLETED

# Periodic tasks
@queue.periodic(seconds=300)
async def cleanup():
    print("Running cleanup...")</code></pre>


        <!-- ‚îÄ‚îÄ‚îÄ GRAPHQL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h2 id="graphql">GraphQL</h2>
        <p>Built-in GraphQL engine with queries, mutations, subscriptions, and an interactive GraphiQL IDE.</p>
        <pre><code>from ishaa.graphql import GraphQLSchema, mount_graphql

schema = GraphQLSchema()

@schema.query("hello")
async def resolve_hello(name: str = "World"):
    return f"Hello, {name}!"

@schema.query("users")
async def resolve_users():
    return [{"id": 1, "name": "Alice"}, {"id": 2, "name": "Bob"}]

@schema.mutation("createUser")
async def create_user(name: str, email: str):
    return {"id": 3, "name": name, "email": email}

mount_graphql(app, schema, path="/graphql")
# Visit http://localhost:8000/graphql for GraphiQL IDE</code></pre>


        <!-- ‚îÄ‚îÄ‚îÄ DEPENDENCY INJECTION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h2 id="dependency-injection">Dependency Injection</h2>
        <p>FastAPI-style dependency injection with async support and automatic cleanup.</p>
        <pre><code>from ishaa.di import Depends, inject

async def get_db():
    db = Database("app.db")
    yield db  # Generator deps are auto-cleaned up

async def get_current_user(request):
    token = request.headers.get("authorization", "").replace("Bearer ", "")
    if not token:
        from ishaa.di import HTTPException
        raise HTTPException(401, "Not authenticated")
    return jwt.decode(token)

@app.route("/profile")
@inject
async def profile(request, user=Depends(get_current_user), db=Depends(get_db)):
    return {"user": user}</code></pre>

        <div class="docs-tip docs-tip-info">
            <strong>Tip</strong>
            Dependencies are cached per-request by default. Use <code>Depends(func, use_cache=False)</code> to create a fresh instance each time.
        </div>


        <!-- ‚îÄ‚îÄ‚îÄ PLUGINS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h2 id="plugins">Plugins</h2>
        <p>Extend Ishaa with a clean plugin system for caching, static files, mail, and admin.</p>

        <h3>Cache Plugin</h3>
        <pre><code>from ishaa.plugins import CachePlugin

cache = CachePlugin(default_ttl=300, max_size=1000)
app.register_plugin(cache)

@app.route("/expensive")
@cache.cached(ttl=60)
async def expensive(request):
    return {"result": compute_something()}</code></pre>

        <h3>Static Files Plugin</h3>
        <pre><code>from ishaa.plugins import StaticFilesPlugin

static = StaticFilesPlugin(directory="static", prefix="/static")
app.register_plugin(static)
# Serves files from ./static/ at /static/...</code></pre>

        <h3>Mail Plugin</h3>
        <pre><code>from ishaa.plugins import MailPlugin

mail = MailPlugin(host="smtp.example.com", port=587,
    username="user", password="pass", use_tls=True)
app.register_plugin(mail)

await mail.send(to="user@example.com", subject="Hello", body="Welcome!")</code></pre>

        <h3>Admin Plugin</h3>
        <pre><code>from ishaa.plugins import AdminPlugin

admin = AdminPlugin(prefix="/admin", title="My Admin")
admin.register_model(User)
admin.register_model(Post)
app.register_plugin(admin)
# Dashboard at /admin, model views at /admin/users, /admin/posts</code></pre>


        <!-- ‚îÄ‚îÄ‚îÄ OPENAPI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h2 id="openapi">OpenAPI / Swagger</h2>
        <p>Auto-generated API documentation with Swagger UI.</p>
        <pre><code>from ishaa.openapi import mount_docs

mount_docs(app, title="My API", version="1.0.0", description="My awesome API")
# Swagger UI at /docs
# OpenAPI JSON at /openapi.json</code></pre>


        <!-- ‚îÄ‚îÄ‚îÄ TESTING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h2 id="testing">Testing</h2>
        <p>Built-in test client for HTTP-level testing without running the server.</p>
        <pre><code>from ishaa.testing import TestClient, assert_status, assert_json

client = TestClient(app)

# Make requests
response = client.get("/")
assert response.ok
assert response.status_code == 200

response = client.post("/api/users", json={"name": "Alice"})
assert response.status_code == 201

# With auth headers
response = client.get("/protected",
    headers={"Authorization": "Bearer &lt;token&gt;"})

# Assertion helpers
assert_status(response, 200)
assert_json(response, {"ok": True})
assert_html(response, contains="&lt;h1&gt;")
assert_redirect(response, "/login")</code></pre>

        <h3>Available Methods</h3>
        <table>
            <thead><tr><th>Method</th><th>Description</th></tr></thead>
            <tbody>
                <tr><td><code>client.get(path)</code></td><td>GET request</td></tr>
                <tr><td><code>client.post(path, json=...)</code></td><td>POST with JSON body</td></tr>
                <tr><td><code>client.put(path, data=...)</code></td><td>PUT request</td></tr>
                <tr><td><code>client.patch(path, json=...)</code></td><td>PATCH request</td></tr>
                <tr><td><code>client.delete(path)</code></td><td>DELETE request</td></tr>
            </tbody>
        </table>


        <!-- ‚îÄ‚îÄ‚îÄ CLI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h2 id="cli">CLI Tool</h2>
        <p>Ishaa includes a command-line tool for common development tasks.</p>
        <pre><code># Scaffold a new project
$ ishaa create project myapp

# Start development server
$ ishaa run --host 0.0.0.0 --port 8000 --reload

# Database migrations
$ ishaa migrate run
$ ishaa migrate create add_users_table

# List registered routes
$ ishaa routes

# Interactive shell
$ ishaa shell

# Version info
$ ishaa version</code></pre>

        <table>
            <thead><tr><th>Command</th><th>Description</th><th>Key Options</th></tr></thead>
            <tbody>
                <tr><td><code>ishaa create project &lt;name&gt;</code></td><td>Scaffold project</td><td><code>--minimal</code></td></tr>
                <tr><td><code>ishaa run</code></td><td>Run dev server</td><td><code>--host</code>, <code>--port</code>, <code>--debug</code>, <code>--reload</code></td></tr>
                <tr><td><code>ishaa routes</code></td><td>List routes</td><td>-</td></tr>
                <tr><td><code>ishaa shell</code></td><td>Interactive shell</td><td>-</td></tr>
                <tr><td><code>ishaa version</code></td><td>Show version</td><td>-</td></tr>
            </tbody>
        </table>


        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
             SARE ENGINE
             ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <h2 id="sare-overview">SARE - Self-Evolving Adaptive Routing Engine</h2>
        <p>SARE is the world's first web framework feature that <strong>automatically observes, decides, adapts, and evolves</strong> its own routing and middleware execution based on real-time traffic intelligence. No external ML libraries required - everything runs in pure Python.</p>

        <h3>How SARE Works</h3>
        <ol>
            <li><strong>Observe</strong> - The Traffic Analyzer collects per-route metrics: latency percentiles, RPS, error rates, response sizes, and heat scores.</li>
            <li><strong>Decide</strong> - The Adaptive Optimizer identifies hot routes and evaluates middleware ordering efficiency.</li>
            <li><strong>Adapt</strong> - Hot routes are promoted to O(1) fast-path caches. Middleware is auto-reordered for maximum short-circuit efficiency.</li>
            <li><strong>Evolve</strong> - The Latency Predictor uses EWMA, trend detection, spike detection, and reinforcement heuristics to continuously improve predictions and strategy selection.</li>
        </ol>


        <h2 id="sare-quickstart">SARE Quick Start</h2>
        <pre><code>from ishaa import Ishaa

app = Ishaa("myapp")
app.enable_sare()  # That's it - self-optimization begins

@app.route("/api/data")
async def data(request):
    return {"items": await fetch_items()}

# Access the intelligence dashboard
@app.route("/sare/report")
async def intelligence(request):
    return app.sare.report()    # Full JSON report

@app.route("/sare/print")
async def sare_print(request):
    app.sare.print_report()     # Console output
    return {"status": "printed"}

app.run()</code></pre>


        <h2 id="sare-traffic">Traffic Analyzer</h2>
        <p>The observation layer that collects real-time per-route and per-middleware metrics.</p>

        <h3>Metrics Collected Per Route</h3>
        <table>
            <thead><tr><th>Metric</th><th>Description</th></tr></thead>
            <tbody>
                <tr><td><code>total_requests</code></td><td>Total number of requests served</td></tr>
                <tr><td><code>avg_latency</code></td><td>Average response latency (ms)</td></tr>
                <tr><td><code>p50_latency</code></td><td>Median latency</td></tr>
                <tr><td><code>p95_latency</code></td><td>95th percentile latency</td></tr>
                <tr><td><code>p99_latency</code></td><td>99th percentile latency</td></tr>
                <tr><td><code>requests_per_second</code></td><td>Current RPS (rolling window)</td></tr>
                <tr><td><code>error_rate</code></td><td>Ratio of errors to total requests</td></tr>
                <tr><td><code>heat_score</code></td><td>0‚Äì1 composite score (frequency √ó 0.5 + latency √ó 0.3 + errors √ó 0.2)</td></tr>
            </tbody>
        </table>

        <h3>Middleware Metrics</h3>
        <table>
            <thead><tr><th>Metric</th><th>Description</th></tr></thead>
            <tbody>
                <tr><td><code>avg_latency</code></td><td>Average middleware execution time</td></tr>
                <tr><td><code>short_circuit_rate</code></td><td>Ratio of requests short-circuited by this middleware</td></tr>
                <tr><td><code>total_calls</code></td><td>Number of times middleware was invoked</td></tr>
            </tbody>
        </table>


        <h2 id="sare-optimizer">Adaptive Optimizer</h2>
        <p>The decision-making core that identifies hot routes and optimizes middleware order.</p>

        <h3>Hot Route Caching</h3>
        <p>Routes with the highest heat scores are promoted to an O(1) fast-path lookup cache. When SARE is enabled and a request hits a hot route, the framework checks the response cache <em>before</em> running middleware or the handler.</p>

        <h3>Middleware Auto-Reordering</h3>
        <p>SARE analyzes each middleware's execution cost and short-circuit rate. Middleware that frequently short-circuits (e.g., rate limiting, auth) is promoted to run first, saving downstream computation. The reorder only triggers when the improvement exceeds 15%.</p>

        <pre><code># The optimizer runs automatically. You can query its state:
hot_routes = app.sare.is_hot_route("GET", "/api/data")
order = app.sare.get_optimized_middleware_order()
stats = app.sare.stats()</code></pre>


        <h2 id="sare-predictor">Latency Predictor</h2>
        <p>AI-assisted prediction engine using pure Python - no external ML dependencies.</p>

        <h3>Prediction Algorithms</h3>
        <table>
            <thead><tr><th>Algorithm</th><th>Purpose</th></tr></thead>
            <tbody>
                <tr><td><strong>EWMA</strong></td><td>Exponentially Weighted Moving Average for smooth latency prediction</td></tr>
                <tr><td><strong>Trend Detector</strong></td><td>Linear regression over rolling window to detect rising/falling/stable trends</td></tr>
                <tr><td><strong>Spike Detector</strong></td><td>Z-score based anomaly detection for latency spikes</td></tr>
                <tr><td><strong>Route Strategy</strong></td><td>Reinforcement-style heuristics to choose between caching, async optimization, and precompilation</td></tr>
            </tbody>
        </table>

        <pre><code># Access predictions programmatically
report = app.sare.report()
predictions = report["predictions"]
# Each route gets: predicted RPS, predicted latency,
# spike analysis, and recommended strategy</code></pre>


        <h2 id="sare-codepath">Code Path Optimizer</h2>
        <p>Automatic code path optimization for hot endpoints.</p>

        <h3>Features</h3>
        <ul>
            <li><strong>Response Memoization</strong> - LRU cache with TTL-aware expiration. GET requests to hot endpoints are cached and served without re-executing handlers.</li>
            <li><strong>JSON Pre-Encoding</strong> - Learns structural patterns of JSON responses and creates encoding templates for repeated structures, reducing serialization overhead.</li>
            <li><strong>Handler Caching</strong> - Compiled handler references are cached to avoid repeated lookups.</li>
        </ul>

        <div class="docs-tip docs-tip-info">
            <strong>Auto-Memoize Criteria</strong>
            SARE automatically enables memoization for a route when: it's a GET endpoint, RPS ‚â• 5.0, error rate ‚â§ 2%, and total requests ‚â• 50.
        </div>


        <h2 id="sare-reports">Intelligence Reports</h2>
        <p>SARE generates comprehensive self-improvement reports accessible via API or console.</p>

        <h3>Report Sections</h3>
        <table>
            <thead><tr><th>Section</th><th>Contents</th></tr></thead>
            <tbody>
                <tr><td><strong>Traffic Overview</strong></td><td>Total routes, total requests, global RPS, hottest routes, error-prone routes</td></tr>
                <tr><td><strong>Route Intelligence</strong></td><td>Per-route metrics, percentiles, heat scores, predictions</td></tr>
                <tr><td><strong>Middleware Intelligence</strong></td><td>Per-middleware timing, short-circuit rates, optimal order</td></tr>
                <tr><td><strong>Predictions</strong></td><td>RPS forecasts, latency forecasts, spike warnings, strategy recommendations</td></tr>
                <tr><td><strong>Optimizations Applied</strong></td><td>Hot route cache status, middleware reorder status, suggestions</td></tr>
                <tr><td><strong>Evolution History</strong></td><td>Timeline of all optimization decisions with before/after metrics</td></tr>
                <tr><td><strong>Performance Delta</strong></td><td>Before vs. after comparison of latency, RPS, and cache hit rates</td></tr>
                <tr><td><strong>Recommendations</strong></td><td>Actionable suggestions for further optimization</td></tr>
            </tbody>
        </table>

        <h3>Accessing Reports</h3>
        <pre><code># JSON report (for API endpoints)
report = app.sare.report()

# Pretty-printed console output
app.sare.print_report()

# Raw JSON string
json_str = app.sare.report_json()

# Quick stats summary
stats = app.sare.stats()</code></pre>


        <h2 id="sare-config">SARE Configuration</h2>
        <p>All SARE parameters are configurable via <code>enable_sare()</code>:</p>
        <pre><code>app.enable_sare(
    optimize_interval=10,   # Seconds between optimization cycles
    cache_size=500,         # Max entries in response cache
    cache_ttl=30,           # Default cache TTL in seconds
    hot_route_slots=20,     # Number of hot route slots
    middleware_reorder=True, # Enable middleware auto-reordering
    predictor=True,          # Enable latency predictor
    auto_memoize=True,       # Enable auto-memoization
)</code></pre>

        <table>
            <thead><tr><th>Parameter</th><th>Default</th><th>Description</th></tr></thead>
            <tbody>
                <tr><td><code>optimize_interval</code></td><td>10</td><td>Seconds between optimization cycles</td></tr>
                <tr><td><code>cache_size</code></td><td>500</td><td>Maximum entries in response cache</td></tr>
                <tr><td><code>cache_ttl</code></td><td>30</td><td>Default cache TTL in seconds</td></tr>
                <tr><td><code>hot_route_slots</code></td><td>20</td><td>Number of hot route fast-path slots</td></tr>
                <tr><td><code>middleware_reorder</code></td><td><code>True</code></td><td>Enable middleware auto-reordering</td></tr>
                <tr><td><code>predictor</code></td><td><code>True</code></td><td>Enable the latency predictor</td></tr>
                <tr><td><code>auto_memoize</code></td><td><code>True</code></td><td>Auto-enable memoization for hot routes</td></tr>
            </tbody>
        </table>

        <h3>Control at Runtime</h3>
        <pre><code># Disable SARE temporarily
app.sare.disable()

# Re-enable
app.sare.enable()

# Reset all collected data
app.sare.reset()</code></pre>


        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
             RMF ENGINE
             ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <h2 id="rmf-overview">RMF - Reality-Mode Framework</h2>
        <p>RMF is the world's first execution-layer abstraction that allows the <strong>same route to exist in multiple behavioral universes</strong>. Each request can enter a different "reality" with different logic, middleware, caching, and security rules - without conditional clutter or branching code.</p>

        <h3>How RMF Works</h3>
        <ol>
            <li><strong>Define Realities</strong> - Use <code>@app.reality()</code> decorators to create multiple handlers for the same route, each in a named reality (e.g., "stable", "experimental", "beta").</li>
            <li><strong>Reality Selection</strong> - The Reality Selector Engine routes each request into the appropriate reality via traffic percentage, sticky sessions, behavior rules, or time windows.</li>
            <li><strong>Parallel Simulation</strong> - Optionally run shadow realities in parallel to compare outputs and measure drift - without affecting production users.</li>
            <li><strong>Self-Retiring</strong> - Experimental realities auto-promote to stable once they prove themselves through low error rates and acceptable latency.</li>
        </ol>


        <h2 id="rmf-quickstart">RMF Quick Start</h2>
        <pre><code>from ishaa import Ishaa

app = Ishaa("myapp")
app.enable_rmf()

# Same route - two realities
@app.route("/recommend")
@app.reality("stable")
async def recommend_v1(request):
    return {"algo": "classic"}

@app.route("/recommend")
@app.reality("experimental", traffic_pct=20)
async def recommend_v2(request):
    return {"algo": "neural"}
# 80% of users see "classic", 20% see "neural"

# Access RMF report
@app.route("/rmf/report")
async def rmf_report(request):
    return app.rmf.report()

app.run()</code></pre>

        <div class="docs-tip docs-tip-info">
            <strong>Tip</strong>
            The "stable" reality is always the default. If no other reality qualifies, users are routed to stable.
        </div>


        <h2 id="rmf-selector">Reality Selector Engine</h2>
        <p>The Reality Selector routes each request using a priority-based selection chain:</p>

        <h3>Selection Priority</h3>
        <table>
            <thead><tr><th>Priority</th><th>Method</th><th>Description</th></tr></thead>
            <tbody>
                <tr><td>1</td><td><strong>Explicit Header</strong></td><td><code>X-Reality: experimental</code> header overrides all other selection</td></tr>
                <tr><td>2</td><td><strong>Sticky Cookie</strong></td><td>Returning users stay in the same reality for consistency</td></tr>
                <tr><td>3</td><td><strong>Behavior Rules</strong></td><td>Custom functions evaluate request properties to choose reality</td></tr>
                <tr><td>4</td><td><strong>Time Windows</strong></td><td>Only time-active realities are considered</td></tr>
                <tr><td>5</td><td><strong>Traffic Percentage</strong></td><td>Deterministic hash-based allocation using client IP + user-agent</td></tr>
            </tbody>
        </table>

        <h3>Custom Behavior Rules</h3>
        <pre><code>@app.rmf_behavior_rule
def route_by_header(request, realities):
    if request.headers.get("x-beta") == "1":
        return "beta" if "beta" in realities else None
    return None

@app.rmf_behavior_rule
def route_premium_users(request, realities):
    if request.headers.get("x-plan") == "premium":
        return "premium" if "premium" in realities else None
    return None</code></pre>


        <h2 id="rmf-time-bound">Time-Bound Realities</h2>
        <p>Schedule realities to activate during specific date ranges. Ideal for holiday features, seasonal promotions, or staged rollouts.</p>
        <pre><code>@app.route("/pricing")
@app.reality("holiday_sale", active_between="Dec 20 - Jan 05",
             traffic_pct=100)
async def holiday_pricing(request):
    return {"discount": "30%", "event": "Holiday Sale"}

@app.route("/pricing")
@app.reality("stable")
async def normal_pricing(request):
    return {"discount": "0%"}</code></pre>

        <div class="docs-tip docs-tip-info">
            <strong>Supported Formats</strong>
            Time windows accept: <code>Mon DD - Mon DD</code>, <code>YYYY-MM-DD - YYYY-MM-DD</code>, <code>B DD - B DD</code> (full month names), and <code>MM/DD - MM/DD</code>.
        </div>


        <h2 id="rmf-parallel">Parallel Simulation</h2>
        <p>Run multiple realities simultaneously for the same request. The user sees the primary reality's response while shadow realities execute silently for comparison.</p>

        <pre><code># Enable parallel simulation
app.enable_rmf(enable_parallel_sim=True)

# All realities run in parallel
# Primary response goes to user
# Shadow results logged for drift analysis</code></pre>

        <h3>Drift Measurement</h3>
        <table>
            <thead><tr><th>Metric</th><th>Description</th></tr></thead>
            <tbody>
                <tr><td><code>drift_score</code></td><td>0.0‚Äì1.0 behavioral difference (0 = identical, 1 = completely different)</td></tr>
                <tr><td><code>shadow_latency</code></td><td>Execution time of the shadow reality</td></tr>
                <tr><td><code>primary_latency</code></td><td>Execution time of the primary reality</td></tr>
                <tr><td><code>shadow_status</code></td><td>Success/error status of shadow execution</td></tr>
            </tbody>
        </table>

        <pre><code># Access parallel simulation comparison logs
report = app.rmf.report()
comparisons = report["parallel_simulations"]</code></pre>


        <h2 id="rmf-self-retiring">Self-Retiring Realities</h2>
        <p>Experimental realities can auto-promote to replace the stable handler when they prove reliability:</p>

        <pre><code>@app.route("/api/search")
@app.reality("experimental",
    traffic_pct=10,
    auto_promote=True,
    promote_after_requests=1000,
    promote_error_threshold=0.02,
    promote_latency_ratio=1.1)
async def search_v2(request):
    return {"engine": "upgraded"}
# After 1000 requests, if error rate &lt; 2%
# and latency within 110% of stable:
#   ‚Üí auto-promotes to new "stable"</code></pre>

        <h3>Promotion Criteria</h3>
        <table>
            <thead><tr><th>Parameter</th><th>Default</th><th>Description</th></tr></thead>
            <tbody>
                <tr><td><code>auto_promote</code></td><td><code>False</code></td><td>Enable auto-promotion for this reality</td></tr>
                <tr><td><code>promote_after_requests</code></td><td>1000</td><td>Minimum requests before considering promotion</td></tr>
                <tr><td><code>promote_error_threshold</code></td><td>0.02</td><td>Maximum error rate (2%) to qualify</td></tr>
                <tr><td><code>promote_latency_ratio</code></td><td>1.1</td><td>Max latency vs stable (110%)</td></tr>
            </tbody>
        </table>


        <h2 id="rmf-config">RMF Configuration</h2>
        <p>Configure RMF via <code>enable_rmf()</code>:</p>
        <pre><code>app.enable_rmf(
    auto_promote_threshold=1000,    # Default request threshold
    auto_promote_error_max=0.02,    # Max error rate for promotion
    auto_promote_latency_ratio=1.5, # Max latency ratio vs stable
    enable_parallel_sim=False,      # Enable parallel simulation
    enable_self_retiring=True,      # Enable self-retiring engine
)</code></pre>

        <table>
            <thead><tr><th>Parameter</th><th>Default</th><th>Description</th></tr></thead>
            <tbody>
                <tr><td><code>auto_promote_threshold</code></td><td>1000</td><td>Default request threshold for auto-promotion</td></tr>
                <tr><td><code>auto_promote_error_max</code></td><td>0.02</td><td>Maximum error rate for promotion eligibility</td></tr>
                <tr><td><code>auto_promote_latency_ratio</code></td><td>1.5</td><td>Experimental latency must be within this ratio of stable</td></tr>
                <tr><td><code>enable_parallel_sim</code></td><td><code>False</code></td><td>Enable parallel simulation mode</td></tr>
                <tr><td><code>enable_self_retiring</code></td><td><code>True</code></td><td>Enable the self-retiring engine</td></tr>
            </tbody>
        </table>

        <h3>Reality Decorator Options</h3>
        <table>
            <thead><tr><th>Option</th><th>Type</th><th>Description</th></tr></thead>
            <tbody>
                <tr><td><code>traffic_pct</code></td><td><code>float</code></td><td>Percentage of traffic (0‚Äì100)</td></tr>
                <tr><td><code>active_between</code></td><td><code>str</code></td><td>Time window for auto-activation</td></tr>
                <tr><td><code>sticky</code></td><td><code>bool</code></td><td>Enable sticky sessions (default: True)</td></tr>
                <tr><td><code>auto_promote</code></td><td><code>bool</code></td><td>Enable auto-promotion</td></tr>
                <tr><td><code>middleware</code></td><td><code>list</code></td><td>Reality-scoped middleware</td></tr>
                <tr><td><code>cache_ttl</code></td><td><code>float</code></td><td>Cache TTL override for this reality</td></tr>
                <tr><td><code>priority</code></td><td><code>int</code></td><td>Selection priority (higher = preferred)</td></tr>
                <tr><td><code>tags</code></td><td><code>dict</code></td><td>Metadata tags</td></tr>
            </tbody>
        </table>


        <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
             SEQP ENGINE
             ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
        <h2 id="seqp-overview">SEQP - Self-Evolving Quality Pipeline</h2>
        <p>SEQP is the world's first framework feature that <strong>continuously analyzes application logic, generates adversarial tests, rewrites CI/CD pipelines, and enforces dynamic deployment policies</strong> based on code complexity and runtime behavior. Five layers work together to evolve your quality pipeline.</p>

        <h3>The Five Layers</h3>
        <ol>
            <li><strong>Risk Analyzer</strong> - AST-powered code analysis measuring branch density, complexity, state mutation risk, and more</li>
            <li><strong>Auto Test Generator</strong> - Risk-targeted test generation (boundary, concurrency, security, load)</li>
            <li><strong>Pipeline Rewriter</strong> - Auto-generates/updates GitHub Actions or GitLab CI configurations</li>
            <li><strong>Deployment Guard</strong> - Dynamic coverage thresholds and quality gates per route criticality</li>
            <li><strong>Drift Intelligence</strong> - Trend tracking, anomaly detection, and health scoring over time</li>
        </ol>


        <h2 id="seqp-quickstart">SEQP Quick Start</h2>
        <pre><code>from ishaa import Ishaa

app = Ishaa("myapp")
app.enable_seqp(pipeline_platform="github_actions")

@app.route("/payment")
@app.critical(level="financial_core")
async def process_payment(request):
    data = await request.json()
    return {"status": "processed", "amount": data["amount"]}

@app.route("/api/health")
async def health(request):
    return {"status": "ok"}

# Trigger analysis + test generation + pipeline rewrite
report = app.seqp.evolve()

# View quality report
quality = app.seqp.report()
app.run()</code></pre>

        <div class="docs-tip docs-tip-info">
            <strong>Tip</strong>
            The <code>@app.critical()</code> decorator tags routes with business criticality. SEQP uses this to calibrate risk thresholds, test intensity, and deployment gates.
        </div>


        <h2 id="seqp-risk">Risk Analyzer</h2>
        <p>The Risk Analyzer uses Python's AST module to parse and analyze source code, producing risk metrics per route handler.</p>

        <h3>Metrics Collected</h3>
        <table>
            <thead><tr><th>Metric</th><th>Description</th><th>Risk Weight</th></tr></thead>
            <tbody>
                <tr><td><code>branch_density</code></td><td>Ratio of decision points to lines of code</td><td>20%</td></tr>
                <tr><td><code>cyclomatic_complexity</code></td><td>Number of independent code paths</td><td>20%</td></tr>
                <tr><td><code>nesting_depth</code></td><td>Maximum nesting level of control structures</td><td>10%</td></tr>
                <tr><td><code>state_mutations</code></td><td>Assignments to <code>self.*</code> or globals</td><td>15%</td></tr>
                <tr><td><code>db_interactions</code></td><td>SQL/ORM pattern matches</td><td>10%</td></tr>
                <tr><td><code>concurrency_indicators</code></td><td>Async, threading, lock patterns</td><td>10%</td></tr>
                <tr><td><code>external_calls</code></td><td>HTTP, SMTP, Redis pattern matches</td><td>5%</td></tr>
                <tr><td><code>input_parsing</code></td><td>Request body/JSON/form parsing</td><td>5%</td></tr>
                <tr><td><code>security_sensitive</code></td><td>Password, token, payment patterns</td><td>5%</td></tr>
            </tbody>
        </table>

        <h3>Risk Levels</h3>
        <table>
            <thead><tr><th>Level</th><th>Score Range</th><th>Recommended Coverage</th></tr></thead>
            <tbody>
                <tr><td><code>LOW</code></td><td>0.0 ‚Äì 0.29</td><td>75%</td></tr>
                <tr><td><code>MEDIUM</code></td><td>0.30 ‚Äì 0.49</td><td>85%</td></tr>
                <tr><td><code>HIGH</code></td><td>0.50 ‚Äì 0.69</td><td>90%</td></tr>
                <tr><td><code>CRITICAL</code></td><td>0.70 ‚Äì 1.0</td><td>95%</td></tr>
            </tbody>
        </table>

        <pre><code># Analyze a specific handler
profile = app.seqp.risk_analyzer.profile_route(process_payment, "financial_core")
print(profile["metrics"]["risk_score"])    # 0.0 ‚Äì 1.0
print(profile["metrics"]["risk_level"])    # LOW / MEDIUM / HIGH / CRITICAL
print(profile["recommended_coverage"])     # 0.95
print(profile["recommended_tests"])        # ["unit", "boundary", ...]</code></pre>


        <h2 id="seqp-testgen">Auto Test Generator</h2>
        <p>SEQP generates test specifications based on route risk profiles - not random fuzzing, but <strong>risk-targeted generation</strong>.</p>

        <h3>Test Types Generated</h3>
        <table>
            <thead><tr><th>Test Type</th><th>Trigger</th><th>Description</th></tr></thead>
            <tbody>
                <tr><td><code>basic</code></td><td>Always</td><td>Happy-path request validation</td></tr>
                <tr><td><code>boundary</code></td><td>Branch density &gt; 3</td><td>Edge case inputs, empty values, type mismatches</td></tr>
                <tr><td><code>concurrency</code></td><td>Async/threading detected</td><td>Parallel request simulation for race conditions</td></tr>
                <tr><td><code>security_payload</code></td><td>Input parsing detected</td><td>SQL injection, XSS, path traversal payloads</td></tr>
                <tr><td><code>schema_drift</code></td><td>DB interactions &gt; 2</td><td>Schema consistency validation</td></tr>
                <tr><td><code>load_burst</code></td><td>Critical or high risk</td><td>Concurrent request stress testing</td></tr>
                <tr><td><code>mutation</code></td><td>Financial core or risk &gt; 0.7</td><td>Mutation testing for logic correctness</td></tr>
            </tbody>
        </table>

        <pre><code># Generate test code for all routes
tests = app.seqp.generate_all_tests()
test_code = app.seqp.test_generator.generate_test_code(tests)
# Produces executable pytest-compatible test file</code></pre>


        <h2 id="seqp-pipeline">Pipeline Rewriter</h2>
        <p>SEQP automatically generates CI/CD pipeline configurations based on your application's risk profile.</p>

        <h3>Supported Platforms</h3>
        <table>
            <thead><tr><th>Platform</th><th>Value</th><th>Output Format</th></tr></thead>
            <tbody>
                <tr><td>GitHub Actions</td><td><code>"github_actions"</code></td><td>YAML workflow</td></tr>
                <tr><td>GitLab CI</td><td><code>"gitlab_ci"</code></td><td>YAML pipeline</td></tr>
            </tbody>
        </table>

        <pre><code>app.enable_seqp(
    pipeline_platform="github_actions",
    pipeline_output=".github/workflows/seqp.yml"
)

# Generates pipeline with:
# - Dynamic coverage thresholds per criticality
# - Risk-based test stages
# - Deployment gates
# - Quality checkpoints</code></pre>

        <div class="docs-tip docs-tip-info">
            <strong>Tip</strong>
            The generated pipeline adapts as your code changes. Run <code>app.seqp.evolve()</code> to re-analyze and regenerate.
        </div>


        <h2 id="seqp-guard">Deployment Guard</h2>
        <p>Dynamic quality gates that adjust coverage requirements based on route criticality.</p>

        <h3>Criticality Levels</h3>
        <table>
            <thead><tr><th>Level</th><th>Description</th><th>Min Coverage</th></tr></thead>
            <tbody>
                <tr><td><code>financial_core</code></td><td>Payment, billing, transactions</td><td>95%</td></tr>
                <tr><td><code>security_critical</code></td><td>Auth, encryption, token routes</td><td>92%</td></tr>
                <tr><td><code>data_critical</code></td><td>Data mutation, migrations</td><td>90%</td></tr>
                <tr><td><code>standard</code></td><td>Normal routes (default)</td><td>75%</td></tr>
            </tbody>
        </table>

        <pre><code>@app.route("/payment")
@app.critical(level="financial_core")
async def payment(request):
    ...

@app.route("/auth/login")
@app.critical(level="security_critical")
async def login(request):
    ...

@app.route("/api/users", methods=["DELETE"])
@app.critical(level="data_critical", description="Deletes user data")
async def delete_user(request):
    ...

# Check deployment readiness
guard = app.seqp.deployment_check()
# {"allowed": True/False, "gates": [...], "coverage": {...}}</code></pre>


        <h2 id="seqp-drift">Drift Intelligence</h2>
        <p>Continuously tracks quality metrics over time to detect degradation trends and anomalies.</p>

        <h3>Tracked Metrics</h3>
        <table>
            <thead><tr><th>Metric</th><th>Description</th></tr></thead>
            <tbody>
                <tr><td><code>latency_drift</code></td><td>Change in response latency over rolling baseline</td></tr>
                <tr><td><code>error_rate_drift</code></td><td>Change in error rate vs historical average</td></tr>
                <tr><td><code>risk_evolution</code></td><td>How risk scores change as code evolves</td></tr>
                <tr><td><code>deployment_health</code></td><td>Composite health score post-deployment</td></tr>
                <tr><td><code>anomaly_flags</code></td><td>Statistical anomaly detection triggers</td></tr>
            </tbody>
        </table>

        <pre><code># Access drift intelligence
report = app.seqp.report()
drift = report.get("drift_intelligence", {})
# Timeline of risk changes, latency trends, health scores</code></pre>

        <div class="docs-tip docs-tip-warn">
            <strong>Warning</strong>
            When <code>latency_drift_tolerance</code> is exceeded (default: 20%), SEQP flags the deployment as degraded and may block future deployments until the issue is addressed.
        </div>


        <h2 id="seqp-config">SEQP Configuration</h2>
        <p>Configure SEQP via <code>enable_seqp()</code>:</p>
        <pre><code>app.enable_seqp(
    scan_paths=["./"],                # Paths to scan for risk analysis
    pipeline_platform="github_actions", # CI/CD platform
    pipeline_output=".github/workflows/seqp.yml",
    latency_drift_tolerance=0.20,     # 20% max latency increase
    error_rate_threshold=0.02,        # 2% max error rate
    auto_generate_tests=True,         # Auto-generate tests on evolve
    auto_rewrite_pipeline=True,       # Auto-rewrite CI/CD config
)</code></pre>

        <table>
            <thead><tr><th>Parameter</th><th>Default</th><th>Description</th></tr></thead>
            <tbody>
                <tr><td><code>scan_paths</code></td><td><code>["./"]</code></td><td>Paths to scan for code risk analysis</td></tr>
                <tr><td><code>pipeline_platform</code></td><td><code>"github_actions"</code></td><td>CI/CD platform target</td></tr>
                <tr><td><code>pipeline_output</code></td><td><code>None</code></td><td>Output path for generated pipeline</td></tr>
                <tr><td><code>latency_drift_tolerance</code></td><td>0.20</td><td>Max allowed latency increase (20%)</td></tr>
                <tr><td><code>error_rate_threshold</code></td><td>0.02</td><td>Max error rate for deployment</td></tr>
                <tr><td><code>auto_generate_tests</code></td><td><code>True</code></td><td>Auto-generate tests on evolve()</td></tr>
                <tr><td><code>auto_rewrite_pipeline</code></td><td><code>True</code></td><td>Auto-rewrite CI/CD on evolve()</td></tr>
            </tbody>
        </table>

        <h3>Full Evolution Cycle</h3>
        <pre><code># Run the full SEQP evolution cycle
result = app.seqp.evolve()
# 1. Scans all handlers for risk
# 2. Generates adversarial tests
# 3. Rewrites CI/CD pipeline
# 4. Updates deployment gates
# 5. Records drift baseline

print(result["routes_analyzed"])
print(result["tests_generated"])
print(result["pipeline_updated"])
print(result["deployment_status"])</code></pre>


        <!-- ‚îÄ‚îÄ‚îÄ API REFERENCE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h2 id="api-reference">API Reference</h2>

        <h3>Core Exports (<code>from ishaa import ...</code>)</h3>
        <table>
            <thead><tr><th>Export</th><th>Module</th><th>Description</th></tr></thead>
            <tbody>
                <tr><td><code>Ishaa</code></td><td>app</td><td>Core application class</td></tr>
                <tr><td><code>Blueprint</code></td><td>blueprints</td><td>Modular route grouping</td></tr>
                <tr><td><code>Request</code></td><td>request</td><td>HTTP request object</td></tr>
                <tr><td><code>Response</code></td><td>response</td><td>HTTP response base class</td></tr>
                <tr><td><code>JSONResponse</code></td><td>response</td><td>JSON response helper</td></tr>
                <tr><td><code>HTMLResponse</code></td><td>response</td><td>HTML response helper</td></tr>
                <tr><td><code>RedirectResponse</code></td><td>response</td><td>Redirect helper</td></tr>
                <tr><td><code>SARE</code></td><td>sare</td><td>Self-Evolving Adaptive Routing Engine</td></tr>
                <tr><td><code>RealityModeFramework</code></td><td>reality</td><td>Multi-reality route execution engine</td></tr>
                <tr><td><code>SelfEvolvingQualityPipeline</code></td><td>seqp</td><td>Intelligent CI/CD quality pipeline</td></tr>
            </tbody>
        </table>


        <!-- ‚îÄ‚îÄ‚îÄ CONFIGURATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h2 id="configuration">Configuration</h2>
        <p>Configuration can be set during initialization or modified at runtime:</p>
        <pre><code>app = Ishaa("myapp", debug=True)

# Access config
app.config["SECRET_KEY"] = "your-secret"
app.config["HOST"] = "0.0.0.0"
app.config["PORT"] = 3000</code></pre>


        <!-- ‚îÄ‚îÄ‚îÄ ARCHITECTURE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
        <h2 id="architecture">Architecture</h2>
        <pre><code>ishaa/
‚îú‚îÄ‚îÄ __init__.py           # Package exports
‚îú‚îÄ‚îÄ app.py                # Core application (ASGI interface)
‚îú‚îÄ‚îÄ routing.py            # URL routing &amp; pattern matching
‚îú‚îÄ‚îÄ request.py            # HTTP request parsing
‚îú‚îÄ‚îÄ response.py           # HTTP response types
‚îú‚îÄ‚îÄ middleware.py          # Middleware pipeline
‚îú‚îÄ‚îÄ blueprints.py         # Modular route grouping
‚îú‚îÄ‚îÄ server.py             # Built-in ASGI server
‚îú‚îÄ‚îÄ utils.py              # Configuration &amp; utilities
‚îú‚îÄ‚îÄ orm.py                # Database ORM
‚îú‚îÄ‚îÄ auth.py               # Authentication (JWT, sessions, passwords)
‚îú‚îÄ‚îÄ template.py           # Template engine
‚îú‚îÄ‚îÄ tasks.py              # Background task queue
‚îú‚îÄ‚îÄ websocket.py          # WebSocket support
‚îú‚îÄ‚îÄ graphql.py            # GraphQL engine
‚îú‚îÄ‚îÄ openapi.py            # OpenAPI documentation
‚îú‚îÄ‚îÄ di.py                 # Dependency injection
‚îú‚îÄ‚îÄ plugins.py            # Plugin system (cache, static, admin)
‚îú‚îÄ‚îÄ cli.py                # Command-line interface
‚îú‚îÄ‚îÄ testing.py            # Test client &amp; helpers
‚îú‚îÄ‚îÄ sare.py               # SARE unified engine
‚îú‚îÄ‚îÄ sare_traffic.py       # Traffic analyzer
‚îú‚îÄ‚îÄ sare_optimizer.py     # Adaptive optimizer
‚îú‚îÄ‚îÄ sare_predictor.py     # Latency predictor
‚îú‚îÄ‚îÄ sare_codepath.py      # Code path optimizer
‚îú‚îÄ‚îÄ sare_reporter.py      # Intelligence reporter
‚îú‚îÄ‚îÄ reality.py            # RMF - Reality-Mode Framework
‚îî‚îÄ‚îÄ seqp.py               # SEQP - Self-Evolving Quality Pipeline</code></pre>

        <h3>Design Principles</h3>
        <ul>
            <li><strong>Zero dependencies</strong> - Core runs on Python standard library only</li>
            <li><strong>ASGI-native</strong> - Full async support, compatible with uvicorn / hypercorn</li>
            <li><strong>Modular</strong> - Use only what you need</li>
            <li><strong>Convention over configuration</strong> - Sensible defaults, easy overrides</li>
            <li><strong>Developer-first</strong> - Clear errors, intuitive API, minimal boilerplate</li>
            <li><strong>Self-evolving</strong> - SARE observes, decides, adapts, and evolves automatically</li>
            <li><strong>Multi-reality</strong> - RMF lets the same route have multiple behavioral universes</li>
            <li><strong>Quality-intelligent</strong> - SEQP analyzes risk, generates tests, and guards deployments</li>
        </ul>

    </main>
</div>

<!-- Mobile sidebar toggle button -->
<button class="docs-sidebar-toggle" id="docs-sidebar-toggle" aria-label="Toggle docs sidebar">‚ò∞</button>
{% endblock %}

{% block scripts %}
<script src="/static/js/docs.js"></script>
{% endblock %}
